package io.scalaland.endpointstl.akkahttp.testkit

import akka.http.scaladsl.model.HttpRequest
import akka.http.scaladsl.server.{ ExceptionHandler, Route, RoutingLog }
import akka.http.scaladsl.settings.RoutingSettings
import akka.http.scaladsl.testkit.{ RouteTestTimeout, ScalatestRouteTest }
import akka.stream.Materializer
import akka.testkit._
import endpoints.akkahttp.client.EndpointsSettings
import org.scalatest.Suite

import scala.concurrent.duration._
import scala.concurrent.Future

trait ScalatestEndpointsTest extends ScalatestRouteTest { self: Suite =>

  @SuppressWarnings(Array("org.wartremover.warts.Null"))
  trait EndpointsFixture {

    // implement so that both client and server can be created without mocks (other than services implementation)
    implicit val clientInstrumentation = io.scalaland.endpointstl.akkahttp.client.Instrumentation.Noop
    implicit val serverInstrumentation = io.scalaland.endpointstl.akkahttp.server.Instrumentation.Noop

    // use routes generated by server implementation
    def routes: Route

    // for client - makes it reuse AkkaHttpTestkit for tests
    // scalastyle:off
    def defaultEndpointSettings(
      timeout: Int = 10
    )(implicit
      defaultHostInfo:  DefaultHostInfo,
      routingSettings:  RoutingSettings,
      materializer:     Materializer,
      routingLog:       RoutingLog,
      exceptionHandler: ExceptionHandler = null): EndpointsSettings =
      EndpointsSettings(
        requestExecutor = (request: HttpRequest) =>
          // we purposefully evaluate the result synchronously, because if in async we would start
          // calculating value body when Akka HTTP testkit already closed, thus failing tests
          Future.successful {
            implicit val reqTimeout: RouteTestTimeout = RouteTestTimeout(timeout.seconds.dilated)
            request ~> routes ~> check { response }
        }
      )
  }
}
